{"version":3,"names":["_validate","require","_deprecationWarning","utils","validateInternal","validate","NODE_FIELDS","bigIntLiteral","value","toString","node","type","defs","BigIntLiteral","arrayExpression","elements","ArrayExpression","assignmentExpression","operator","left","right","AssignmentExpression","binaryExpression","BinaryExpression","interpreterDirective","InterpreterDirective","directive","Directive","directiveLiteral","DirectiveLiteral","blockStatement","body","directives","BlockStatement","breakStatement","label","BreakStatement","callExpression","callee","_arguments","arguments","CallExpression","catchClause","param","CatchClause","conditionalExpression","test","consequent","alternate","ConditionalExpression","continueStatement","ContinueStatement","debuggerStatement","doWhileStatement","DoWhileStatement","emptyStatement","expressionStatement","expression","ExpressionStatement","file","program","comments","tokens","File","forInStatement","ForInStatement","forStatement","init","update","ForStatement","functionDeclaration","id","params","generator","async","FunctionDeclaration","functionExpression","FunctionExpression","identifier","name","Identifier","ifStatement","IfStatement","labeledStatement","LabeledStatement","stringLiteral","StringLiteral","numericLiteral","NumericLiteral","nullLiteral","booleanLiteral","BooleanLiteral","regExpLiteral","pattern","flags","RegExpLiteral","logicalExpression","LogicalExpression","memberExpression","object","property","computed","optional","MemberExpression","newExpression","NewExpression","sourceType","interpreter","Program","objectExpression","properties","ObjectExpression","objectMethod","kind","key","ObjectMethod","objectProperty","shorthand","decorators","ObjectProperty","restElement","argument","RestElement","returnStatement","ReturnStatement","sequenceExpression","expressions","SequenceExpression","parenthesizedExpression","ParenthesizedExpression","switchCase","SwitchCase","switchStatement","discriminant","cases","SwitchStatement","thisExpression","throwStatement","ThrowStatement","tryStatement","block","handler","finalizer","TryStatement","unaryExpression","prefix","UnaryExpression","updateExpression","UpdateExpression","variableDeclaration","declarations","VariableDeclaration","variableDeclarator","VariableDeclarator","whileStatement","WhileStatement","withStatement","WithStatement","assignmentPattern","AssignmentPattern","arrayPattern","ArrayPattern","arrowFunctionExpression","ArrowFunctionExpression","classBody","ClassBody","classExpression","superClass","ClassExpression","classDeclaration","ClassDeclaration","exportAllDeclaration","source","ExportAllDeclaration","exportDefaultDeclaration","declaration","ExportDefaultDeclaration","exportNamedDeclaration","specifiers","ExportNamedDeclaration","exportSpecifier","local","exported","ExportSpecifier","forOfStatement","_await","await","ForOfStatement","importDeclaration","ImportDeclaration","importDefaultSpecifier","ImportDefaultSpecifier","importNamespaceSpecifier","ImportNamespaceSpecifier","importSpecifier","imported","ImportSpecifier","importExpression","options","ImportExpression","metaProperty","meta","MetaProperty","classMethod","_static","static","ClassMethod","objectPattern","ObjectPattern","spreadElement","SpreadElement","_super","taggedTemplateExpression","tag","quasi","TaggedTemplateExpression","templateElement","tail","TemplateElement","templateLiteral","quasis","TemplateLiteral","yieldExpression","delegate","YieldExpression","awaitExpression","AwaitExpression","_import","exportNamespaceSpecifier","ExportNamespaceSpecifier","optionalMemberExpression","OptionalMemberExpression","optionalCallExpression","OptionalCallExpression","classProperty","typeAnnotation","ClassProperty","classAccessorProperty","ClassAccessorProperty","classPrivateProperty","ClassPrivateProperty","classPrivateMethod","ClassPrivateMethod","privateName","PrivateName","staticBlock","StaticBlock","importAttribute","ImportAttribute","anyTypeAnnotation","arrayTypeAnnotation","elementType","ArrayTypeAnnotation","booleanTypeAnnotation","booleanLiteralTypeAnnotation","BooleanLiteralTypeAnnotation","nullLiteralTypeAnnotation","classImplements","typeParameters","ClassImplements","declareClass","_extends","extends","DeclareClass","declareFunction","DeclareFunction","declareInterface","DeclareInterface","declareModule","DeclareModule","declareModuleExports","DeclareModuleExports","declareTypeAlias","DeclareTypeAlias","declareOpaqueType","supertype","DeclareOpaqueType","declareVariable","DeclareVariable","declareExportDeclaration","attributes","DeclareExportDeclaration","declareExportAllDeclaration","DeclareExportAllDeclaration","declaredPredicate","DeclaredPredicate","existsTypeAnnotation","functionTypeAnnotation","rest","returnType","FunctionTypeAnnotation","functionTypeParam","FunctionTypeParam","genericTypeAnnotation","GenericTypeAnnotation","inferredPredicate","interfaceExtends","InterfaceExtends","interfaceDeclaration","InterfaceDeclaration","interfaceTypeAnnotation","InterfaceTypeAnnotation","intersectionTypeAnnotation","types","IntersectionTypeAnnotation","mixedTypeAnnotation","emptyTypeAnnotation","nullableTypeAnnotation","NullableTypeAnnotation","numberLiteralTypeAnnotation","NumberLiteralTypeAnnotation","numberTypeAnnotation","objectTypeAnnotation","indexers","callProperties","internalSlots","exact","ObjectTypeAnnotation","objectTypeInternalSlot","method","ObjectTypeInternalSlot","objectTypeCallProperty","ObjectTypeCallProperty","objectTypeIndexer","variance","ObjectTypeIndexer","objectTypeProperty","proto","ObjectTypeProperty","objectTypeSpreadProperty","ObjectTypeSpreadProperty","opaqueType","impltype","OpaqueType","qualifiedTypeIdentifier","qualification","QualifiedTypeIdentifier","stringLiteralTypeAnnotation","StringLiteralTypeAnnotation","stringTypeAnnotation","symbolTypeAnnotation","thisTypeAnnotation","tupleTypeAnnotation","TupleTypeAnnotation","typeofTypeAnnotation","TypeofTypeAnnotation","typeAlias","TypeAlias","TypeAnnotation","typeCastExpression","TypeCastExpression","typeParameter","bound","_default","default","TypeParameter","typeParameterDeclaration","TypeParameterDeclaration","typeParameterInstantiation","TypeParameterInstantiation","unionTypeAnnotation","UnionTypeAnnotation","Variance","voidTypeAnnotation","enumDeclaration","EnumDeclaration","enumBooleanBody","members","explicitType","hasUnknownMembers","EnumBooleanBody","enumNumberBody","EnumNumberBody","enumStringBody","EnumStringBody","enumSymbolBody","EnumSymbolBody","enumBooleanMember","EnumBooleanMember","enumNumberMember","EnumNumberMember","enumStringMember","EnumStringMember","enumDefaultedMember","EnumDefaultedMember","indexedAccessType","objectType","indexType","IndexedAccessType","optionalIndexedAccessType","OptionalIndexedAccessType","jsxAttribute","JSXAttribute","jsxClosingElement","JSXClosingElement","jsxElement","openingElement","closingElement","children","selfClosing","JSXElement","jsxEmptyExpression","jsxExpressionContainer","JSXExpressionContainer","jsxSpreadChild","JSXSpreadChild","jsxIdentifier","JSXIdentifier","jsxMemberExpression","JSXMemberExpression","jsxNamespacedName","namespace","JSXNamespacedName","jsxOpeningElement","JSXOpeningElement","jsxSpreadAttribute","JSXSpreadAttribute","jsxText","JSXText","jsxFragment","openingFragment","closingFragment","JSXFragment","jsxOpeningFragment","jsxClosingFragment","noop","placeholder","expectedNode","Placeholder","v8IntrinsicIdentifier","V8IntrinsicIdentifier","argumentPlaceholder","bindExpression","BindExpression","decorator","Decorator","doExpression","DoExpression","exportDefaultSpecifier","ExportDefaultSpecifier","recordExpression","RecordExpression","tupleExpression","TupleExpression","decimalLiteral","DecimalLiteral","moduleExpression","ModuleExpression","topicReference","pipelineTopicExpression","PipelineTopicExpression","pipelineBareFunction","PipelineBareFunction","pipelinePrimaryTopicReference","voidPattern","tsParameterProperty","parameter","TSParameterProperty","tsDeclareFunction","TSDeclareFunction","tsDeclareMethod","TSDeclareMethod","tsQualifiedName","TSQualifiedName","tsCallSignatureDeclaration","parameters","TSCallSignatureDeclaration","tsConstructSignatureDeclaration","TSConstructSignatureDeclaration","tsPropertySignature","TSPropertySignature","tsMethodSignature","TSMethodSignature","tsIndexSignature","TSIndexSignature","tsAnyKeyword","tsBooleanKeyword","tsBigIntKeyword","tsIntrinsicKeyword","tsNeverKeyword","tsNullKeyword","tsNumberKeyword","tsObjectKeyword","tsStringKeyword","tsSymbolKeyword","tsUndefinedKeyword","tsUnknownKeyword","tsVoidKeyword","tsThisType","tsFunctionType","TSFunctionType","tsConstructorType","TSConstructorType","tsTypeReference","typeName","TSTypeReference","tsTypePredicate","parameterName","asserts","TSTypePredicate","tsTypeQuery","exprName","TSTypeQuery","tsTypeLiteral","TSTypeLiteral","tsArrayType","TSArrayType","tsTupleType","elementTypes","TSTupleType","tsOptionalType","TSOptionalType","tsRestType","TSRestType","tsNamedTupleMember","TSNamedTupleMember","tsUnionType","TSUnionType","tsIntersectionType","TSIntersectionType","tsConditionalType","checkType","extendsType","trueType","falseType","TSConditionalType","tsInferType","TSInferType","tsParenthesizedType","TSParenthesizedType","tsTypeOperator","TSTypeOperator","tsIndexedAccessType","TSIndexedAccessType","tsMappedType","nameType","TSMappedType","tsTemplateLiteralType","TSTemplateLiteralType","tsLiteralType","literal","TSLiteralType","tsExpressionWithTypeArguments","TSExpressionWithTypeArguments","tsInterfaceDeclaration","TSInterfaceDeclaration","tsInterfaceBody","TSInterfaceBody","tsTypeAliasDeclaration","TSTypeAliasDeclaration","tsInstantiationExpression","TSInstantiationExpression","tsAsExpression","TSAsExpression","tsSatisfiesExpression","TSSatisfiesExpression","tsTypeAssertion","TSTypeAssertion","tsEnumBody","TSEnumBody","tsEnumDeclaration","TSEnumDeclaration","tsEnumMember","initializer","TSEnumMember","tsModuleDeclaration","TSModuleDeclaration","tsModuleBlock","TSModuleBlock","tsImportType","qualifier","TSImportType","tsImportEqualsDeclaration","moduleReference","isExport","TSImportEqualsDeclaration","tsExternalModuleReference","TSExternalModuleReference","tsNonNullExpression","TSNonNullExpression","tsExportAssignment","TSExportAssignment","tsNamespaceExportDeclaration","TSNamespaceExportDeclaration","tsTypeAnnotation","TSTypeAnnotation","tsTypeParameterInstantiation","TSTypeParameterInstantiation","tsTypeParameterDeclaration","TSTypeParameterDeclaration","tsTypeParameter","constraint","TSTypeParameter","NumberLiteral","deprecationWarning","RegexLiteral","RestProperty","SpreadProperty"],"sources":["../../../src/builders/generated/lowercase.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport * as _validate from \"../../validators/validate.ts\";\nimport type * as t from \"../../ast-types/generated/index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\nimport * as utils from \"../../definitions/utils.ts\";\n\nconst { validateInternal: validate } = _validate;\nconst { NODE_FIELDS } = utils;\n\n/** @deprecated */ export function bigIntLiteral(\n  value: string,\n): t.BigIntLiteral;\nexport function bigIntLiteral(value: bigint): t.BigIntLiteral;\nexport function bigIntLiteral(value: bigint | string): t.BigIntLiteral {\n  if (typeof value === \"bigint\") {\n    value = value.toString();\n  }\n  const node: t.BigIntLiteral = {\n    type: \"BigIntLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function arrayExpression(\n  elements: Array<null | t.Expression | t.SpreadElement> = [],\n): t.ArrayExpression {\n  const node: t.ArrayExpression = {\n    type: \"ArrayExpression\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function assignmentExpression(\n  operator: string,\n  left: t.LVal | t.OptionalMemberExpression,\n  right: t.Expression,\n): t.AssignmentExpression {\n  const node: t.AssignmentExpression = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function binaryExpression(\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\",\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  const node: t.BinaryExpression = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function interpreterDirective(value: string): t.InterpreterDirective {\n  const node: t.InterpreterDirective = {\n    type: \"InterpreterDirective\",\n    value,\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  const node: t.Directive = {\n    type: \"Directive\",\n    value,\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  const node: t.DirectiveLiteral = {\n    type: \"DirectiveLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function blockStatement(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n): t.BlockStatement {\n  const node: t.BlockStatement = {\n    type: \"BlockStatement\",\n    body,\n    directives,\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nexport function breakStatement(\n  label: t.Identifier | null = null,\n): t.BreakStatement {\n  const node: t.BreakStatement = {\n    type: \"BreakStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function callExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.CallExpression {\n  const node: t.CallExpression = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function catchClause(\n  param:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | null\n    | undefined = null,\n  body: t.BlockStatement,\n): t.CatchClause {\n  const node: t.CatchClause = {\n    type: \"CatchClause\",\n    param,\n    body,\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  const node: t.ConditionalExpression = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function continueStatement(\n  label: t.Identifier | null = null,\n): t.ContinueStatement {\n  const node: t.ContinueStatement = {\n    type: \"ContinueStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: \"DebuggerStatement\",\n  };\n}\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  const node: t.DoWhileStatement = {\n    type: \"DoWhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: \"EmptyStatement\",\n  };\n}\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  const node: t.ExpressionStatement = {\n    type: \"ExpressionStatement\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function file(\n  program: t.Program,\n  comments: Array<t.CommentBlock | t.CommentLine> | null = null,\n  tokens: Array<any> | null = null,\n): t.File {\n  const node: t.File = {\n    type: \"File\",\n    program,\n    comments,\n    tokens,\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nexport function forInStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  const node: t.ForInStatement = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body,\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined = null,\n  test: t.Expression | null | undefined = null,\n  update: t.Expression | null | undefined = null,\n  body: t.Statement,\n): t.ForStatement {\n  const node: t.ForStatement = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body,\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.FunctionParameter>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionDeclaration {\n  const node: t.FunctionDeclaration = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function functionExpression(\n  id: t.Identifier | null | undefined = null,\n  params: Array<t.FunctionParameter>,\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionExpression {\n  const node: t.FunctionExpression = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function identifier(name: string): t.Identifier {\n  const node: t.Identifier = {\n    type: \"Identifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null = null,\n): t.IfStatement {\n  const node: t.IfStatement = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  const node: t.LabeledStatement = {\n    type: \"LabeledStatement\",\n    label,\n    body,\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function stringLiteral(value: string): t.StringLiteral {\n  const node: t.StringLiteral = {\n    type: \"StringLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numericLiteral(value: number): t.NumericLiteral {\n  const node: t.NumericLiteral = {\n    type: \"NumericLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: \"NullLiteral\",\n  };\n}\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  const node: t.BooleanLiteral = {\n    type: \"BooleanLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function regExpLiteral(\n  pattern: string,\n  flags: string = \"\",\n): t.RegExpLiteral {\n  const node: t.RegExpLiteral = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags,\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nexport function logicalExpression(\n  operator: \"||\" | \"&&\" | \"??\",\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  const node: t.LogicalExpression = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed: boolean = false,\n  optional: boolean | null = null,\n): t.MemberExpression {\n  const node: t.MemberExpression = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function newExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n): t.NewExpression {\n  const node: t.NewExpression = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function program(\n  body: Array<t.Statement>,\n  directives: Array<t.Directive> = [],\n  sourceType: \"script\" | \"module\" = \"script\",\n  interpreter: t.InterpreterDirective | null = null,\n): t.Program {\n  const node: t.Program = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nexport function objectExpression(\n  properties: Array<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>,\n): t.ObjectExpression {\n  const node: t.ObjectExpression = {\n    type: \"ObjectExpression\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\" | undefined = \"method\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: Array<t.FunctionParameter>,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ObjectMethod {\n  const node: t.ObjectMethod = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.DecimalLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed: boolean = false,\n  shorthand: boolean = false,\n  decorators: Array<t.Decorator> | null = null,\n): t.ObjectProperty {\n  const node: t.ObjectProperty = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function restElement(\n  argument:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression\n    | t.RestElement\n    | t.AssignmentPattern,\n): t.RestElement {\n  const node: t.RestElement = {\n    type: \"RestElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function returnStatement(\n  argument: t.Expression | null = null,\n): t.ReturnStatement {\n  const node: t.ReturnStatement = {\n    type: \"ReturnStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function sequenceExpression(\n  expressions: Array<t.Expression>,\n): t.SequenceExpression {\n  const node: t.SequenceExpression = {\n    type: \"SequenceExpression\",\n    expressions,\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  const node: t.ParenthesizedExpression = {\n    type: \"ParenthesizedExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function switchCase(\n  test: t.Expression | null | undefined = null,\n  consequent: Array<t.Statement>,\n): t.SwitchCase {\n  const node: t.SwitchCase = {\n    type: \"SwitchCase\",\n    test,\n    consequent,\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: Array<t.SwitchCase>,\n): t.SwitchStatement {\n  const node: t.SwitchStatement = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases,\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: \"ThisExpression\",\n  };\n}\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  const node: t.ThrowStatement = {\n    type: \"ThrowStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null = null,\n  finalizer: t.BlockStatement | null = null,\n): t.TryStatement {\n  const node: t.TryStatement = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer,\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nexport function unaryExpression(\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\",\n  argument: t.Expression,\n  prefix: boolean = true,\n): t.UnaryExpression {\n  const node: t.UnaryExpression = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function updateExpression(\n  operator: \"++\" | \"--\",\n  argument: t.Expression,\n  prefix: boolean = false,\n): t.UpdateExpression {\n  const node: t.UpdateExpression = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function variableDeclaration(\n  kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  declarations: Array<t.VariableDeclarator>,\n): t.VariableDeclaration {\n  const node: t.VariableDeclaration = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations,\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nexport function variableDeclarator(\n  id: t.LVal | t.VoidPattern,\n  init: t.Expression | null = null,\n): t.VariableDeclarator {\n  const node: t.VariableDeclarator = {\n    type: \"VariableDeclarator\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  const node: t.WhileStatement = {\n    type: \"WhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  const node: t.WithStatement = {\n    type: \"WithStatement\",\n    object,\n    body,\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  const node: t.AssignmentPattern = {\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function arrayPattern(\n  elements: Array<null | t.PatternLike>,\n): t.ArrayPattern {\n  const node: t.ArrayPattern = {\n    type: \"ArrayPattern\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function arrowFunctionExpression(\n  params: Array<t.FunctionParameter>,\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  const node: t.ArrowFunctionExpression = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null,\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function classBody(\n  body: Array<\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  >,\n): t.ClassBody {\n  const node: t.ClassBody = {\n    type: \"ClassBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassExpression {\n  const node: t.ClassExpression = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function classDeclaration(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: Array<t.Decorator> | null = null,\n): t.ClassDeclaration {\n  const node: t.ClassDeclaration = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  const node: t.ExportAllDeclaration = {\n    type: \"ExportAllDeclaration\",\n    source,\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  const node: t.ExportDefaultDeclaration = {\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: Array<\n    t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier\n  > = [],\n  source: t.StringLiteral | null = null,\n): t.ExportNamedDeclaration {\n  const node: t.ExportNamedDeclaration = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  const node: t.ExportSpecifier = {\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function forOfStatement(\n  left: t.VariableDeclaration | t.LVal,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  const node: t.ForOfStatement = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nexport function importDeclaration(\n  specifiers: Array<\n    t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier\n  >,\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  const node: t.ImportDeclaration = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  const node: t.ImportDefaultSpecifier = {\n    type: \"ImportDefaultSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  const node: t.ImportNamespaceSpecifier = {\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  const node: t.ImportSpecifier = {\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null = null,\n): t.ImportExpression {\n  const node: t.ImportExpression = {\n    type: \"ImportExpression\",\n    source,\n    options,\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  const node: t.MetaProperty = {\n    type: \"MetaProperty\",\n    meta,\n    property,\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: Array<t.FunctionParameter | t.TSParameterProperty>,\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  const node: t.ClassMethod = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectPattern(\n  properties: Array<t.RestElement | t.ObjectProperty>,\n): t.ObjectPattern {\n  const node: t.ObjectPattern = {\n    type: \"ObjectPattern\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  const node: t.SpreadElement = {\n    type: \"SpreadElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super(): t.Super {\n  return {\n    type: \"Super\",\n  };\n}\nexport { _super as super };\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  const node: t.TaggedTemplateExpression = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi,\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nexport function templateElement(\n  value: { raw: string; cooked?: string },\n  tail: boolean = false,\n): t.TemplateElement {\n  const node: t.TemplateElement = {\n    type: \"TemplateElement\",\n    value,\n    tail,\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nexport function templateLiteral(\n  quasis: Array<t.TemplateElement>,\n  expressions: Array<t.Expression | t.TSType>,\n): t.TemplateLiteral {\n  const node: t.TemplateLiteral = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions,\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function yieldExpression(\n  argument: t.Expression | null = null,\n  delegate: boolean = false,\n): t.YieldExpression {\n  const node: t.YieldExpression = {\n    type: \"YieldExpression\",\n    argument,\n    delegate,\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  const node: t.AwaitExpression = {\n    type: \"AwaitExpression\",\n    argument,\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import(): t.Import {\n  return {\n    type: \"Import\",\n  };\n}\nexport { _import as import };\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  const node: t.ExportNamespaceSpecifier = {\n    type: \"ExportNamespaceSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed: boolean | undefined = false,\n  optional: boolean,\n): t.OptionalMemberExpression {\n  const node: t.OptionalMemberExpression = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function optionalCallExpression(\n  callee: t.Expression,\n  _arguments: Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>,\n  optional: boolean,\n): t.OptionalCallExpression {\n  const node: t.OptionalCallExpression = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassProperty {\n  const node: t.ClassProperty = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassAccessorProperty {\n  const node: t.ClassAccessorProperty = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value: t.Expression | null = null,\n  decorators: Array<t.Decorator> | null = null,\n  _static: boolean = false,\n): t.ClassPrivateProperty {\n  const node: t.ClassPrivateProperty = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateMethod(\n  kind: \"get\" | \"set\" | \"method\" | undefined = \"method\",\n  key: t.PrivateName,\n  params: Array<t.FunctionParameter | t.TSParameterProperty>,\n  body: t.BlockStatement,\n  _static: boolean = false,\n): t.ClassPrivateMethod {\n  const node: t.ClassPrivateMethod = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function privateName(id: t.Identifier): t.PrivateName {\n  const node: t.PrivateName = {\n    type: \"PrivateName\",\n    id,\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function staticBlock(body: Array<t.Statement>): t.StaticBlock {\n  const node: t.StaticBlock = {\n    type: \"StaticBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function importAttribute(\n  key: t.Identifier | t.StringLiteral,\n  value: t.StringLiteral,\n): t.ImportAttribute {\n  const node: t.ImportAttribute = {\n    type: \"ImportAttribute\",\n    key,\n    value,\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: \"AnyTypeAnnotation\",\n  };\n}\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  const node: t.ArrayTypeAnnotation = {\n    type: \"ArrayTypeAnnotation\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: \"BooleanTypeAnnotation\",\n  };\n}\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  const node: t.BooleanLiteralTypeAnnotation = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: \"NullLiteralTypeAnnotation\",\n  };\n}\nexport function classImplements(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.ClassImplements {\n  const node: t.ClassImplements = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  const node: t.DeclareClass = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  const node: t.DeclareFunction = {\n    type: \"DeclareFunction\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: Array<t.InterfaceExtends> | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  const node: t.DeclareInterface = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind: \"CommonJS\" | \"ES\" | null = null,\n): t.DeclareModule {\n  const node: t.DeclareModule = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind,\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  const node: t.DeclareModuleExports = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  const node: t.DeclareTypeAlias = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs