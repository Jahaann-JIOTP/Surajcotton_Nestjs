"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scrypt = scrypt;
exports.pbkdf2 = pbkdf2;
exports.deriveMainSeed = deriveMainSeed;
exports.eskdf = eskdf;
/**
 * Experimental KDF for AES.
 */
const hkdf_ts_1 = require("./hkdf.js");
const pbkdf2_ts_1 = require("./pbkdf2.js");
const scrypt_ts_1 = require("./scrypt.js");
const sha256_ts_1 = require("./sha256.js");
const utils_ts_1 = require("./utils.js");
// A tiny KDF for various applications like AES key-gen.
// Uses HKDF in a non-standard way, so it's not "KDF-secure", only "PRF-secure".
// Which is good enough: assume sha2-256 retained preimage resistance.
const SCRYPT_FACTOR = 2 ** 19;
const PBKDF2_FACTOR = 2 ** 17;
// Scrypt KDF
function scrypt(password, salt) {
    return (0, scrypt_ts_1.scrypt)(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 });
}
// PBKDF2-HMAC-SHA256
function pbkdf2(password, salt) {
    return (0, pbkdf2_ts_1.pbkdf2)(sha256_ts_1.sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 });
}
// Combines two 32-byte byte arrays
function xor32(a, b) {
    (0, utils_ts_1.abytes)(a, 32);
    (0, utils_ts_1.abytes)(b, 32);
    const arr = new Uint8Array(32);
    for (let i = 0; i < 32; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function strHasLength(str, min, max) {
    return typeof str === 'string' && str.length >= min && str.length <= max;
}
/**
 * Derives main seed. Takes a lot of time. Prefer `eskdf` method instead.
 */
function deriveMainSeed(username, password) {
    if (!strHasLength(username, 8, 255))
        throw new Error('invalid username');
    if (!strHasLength(password, 8, 255))
        throw new Error('invalid password');
    // Declared like this to throw off minifiers which auto-convert .fromCharCode(1) to actual string.
    // String with non-ascii may be problematic in some envs
    const codes = { _1: 1, _2: 2 };
    const sep = { s: String.fromCharCode(codes._1), p: String.fromCharCode(codes._2) };
    const scr = scrypt(password + sep.s, username + sep.s);
    const pbk = pbkdf2(password + sep.p, username + sep.p);
    const res = xor32(scr, pbk);
    (0, utils_ts_1.clean)(scr, pbk);
    return res;
}
/**
 * Converts protocol & accountId pair to HKDF salt & info params.
 */
function getSaltInfo(protocol, accountId = 0) {
    // Note that length here also repeats two lines below
    // We do an additional length check here to reduce the scope of DoS attacks
    if (!(strHasLength(protocol, 3, 15) && /^[a-z0-9]{3,15}$/.test(protocol))) {
        throw new Error('in